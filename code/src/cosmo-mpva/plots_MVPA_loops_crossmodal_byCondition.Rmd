---
title: "MVPA_PTBUN_2023"
author: "Jacek Matuszewski"
date: '2023-09-15'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load packages
```{r}
library(tidyverse)
library(data.table)
library(cowplot)
library(RColorBrewer)
library(patchwork)
```


Set variables
```{r}


ffx <- 'beta' # beta tmap
featRatio <- '0.8'
#space <-'IXI549Space'
FWHM <- 2
groups <- c('blind', 'sighted') # blind or sighted
# set te path to the task folder
cosmo_results <- '/Volumes/Slim_Reaper/Projects/Language_MVPA/outputs/derivatives/cosmo-mvpa'
#task_audVis <-  paste('task-audVisMotSpatialFreq_space-MNI152NLin2009cAsym_FWHM-', as.character(FWHM), '_node-mvpaBlockAverage', sep ='')
decoding_mod <- 'crossmodal'
task_ReadSpeech <- paste0('task-MultimodalReadSpeech_space-IXI549Space_FWHM-',as.character(FWHM),'_node-mvpa6betas')

decoding_label <- 'JuBrain' #'cVWFA' 'LexPerVWFA'
cosmo_results_path_ReadSpeech <- paste(cosmo_results, task_ReadSpeech,  decoding_label,
                                       decoding_mod,'accuracy', sep ='/')

#namePattern <- paste('sub-',group,'.*_label-VWFAwithinmodal_.*\\.csv$', sep = '')
```


Load results and create group DFs
```{r}
for(g in seq_along(groups)) {
    
    #Set name pattern and get the files
    #namePattern <- paste('sub-',groups[g],'.*_label-VWFAwithinmodal_.*\\.csv$', sep = '')
    #namePattern <- paste('sub-',groups[g],'.*_label-VWFAcrossmodal_.*\\.csv$', sep = '')
    namePattern <- paste('sub-',groups[g],'.*_label-',decoding_label,'_.*\\.csv$', sep = '')
    
    allfiles_ReadSpeech <- list.files(cosmo_results_path_ReadSpeech, pattern = namePattern)
    
    group_df_temp <- lapply(paste(cosmo_results_path_ReadSpeech, 
                                  allfiles_ReadSpeech, sep ='/'), 
                            read.csv, sep =',') %>% 
        rbindlist %>% 
        dplyr::select(!contains('permutation')) %>% 
        mutate(accuracy = accuracy * 100) %>% #make %
        mutate(group = groups[g])#drop the null distribution columns %>%
    
        
    #Rename the group DF
    assign(paste0('mvpa_',groups[g]), group_df_temp)
    rm(group_df_temp)
}

#join the dfs
mvpa_joined <- rbind(mvpa_blind, mvpa_sighted) %>% 
    mutate(conditions = factor(conditions, levels = c('WordPseudoword', 'WordControl',
                                                      'PseudowordControl')))

# COMPUTE SUBJECT-WISE AVERAGE DECODING ACCURACY FOR EACH ROI AND CONDITION 
mvpa_joined_avg <- mvpa_joined %>% 
    group_by(sub, roiArea, conditions) %>% 
    mutate(accuracy_avg = mean(accuracy)) %>% 
    filter(row_number() == 1) %>%
    ungroup() %>% 
    dplyr::select(-c(accuracy, TrainTest)) %>% 
    mutate(TrainTest = 'Average') %>%
    rename(accuracy = accuracy_avg) %>% 
    dplyr::select(colnames(mvpa_joined))

#Paste DFs together for plot purposes
mvpa_joined_avg <- rbind(mvpa_joined_avg, mvpa_joined)  %>% 
    #Factorize for order on the plot
    mutate(TrainTest = factor(TrainTest, levels = c('trainRead_testSpeech', 'Average', 'trainSpeech_testRead'),
                              labels = c('Train on reading, test on speech', 'Average', 'Train on speech, test on reading')))
    

    
rm(mvpa_blind, mvpa_sighted)

```


Specify plotting variables based on the MVPA content (ROIs, decoding conditions)
assumes identical variables between groups! 
```{r}
#Name of ROIs 
roi <- unique(mvpa_joined$roiArea)

#Name of decoding conditions 
classifier <- unique(mvpa_joined$conditions)
modalities <- unique(mvpa_joined$TrainTest)
```

Summarize accuracies for descriptive purposes
```{r}
mvpa_accuracy <-  mvpa_joined %>%
     mutate(conditions = factor(conditions, levels = classifier)) %>% 
        group_by(group, 
                 roiArea,
                 ffxResults,
                 TrainTest,
                 conditions) %>%
        summarize(mean_accuracy = mean(accuracy),
                                sd_accurarcy = sd(accuracy),
                                se_accuracy = sd(accuracy)/sqrt(20),
                                .groups = 'keep')  

mvpa_accuracy_avg <-mvpa_joined %>%
     mutate(conditions = factor(conditions, levels = classifier)) %>% 
        group_by(group, 
                 roiArea,
                 ffxResults,
                 conditions) %>%
        summarize(mean_accuracy = mean(accuracy),
                                sd_accurarcy = sd(accuracy),
                                se_accuracy = sd(accuracy)/sqrt(20),
                                .groups = 'keep')  %>% 
    mutate(TrainTest = 'Average') %>% 
    dplyr::select(group, roiArea, ffxResults, TrainTest, everything())

mvpa_accuracy_joined <- rbind(mvpa_accuracy, mvpa_accuracy_avg) %>% 
    #Factorize for order on the plot
    mutate(TrainTest = factor(TrainTest, levels = c('trainRead_testSpeech', 'Average', 'trainSpeech_testRead'),
                              labels = c('Train on reading, test on speech', 'Average', 'Train on speech, test on reading')))
```



PLOTTING IN A LOOP WITH FUNCTION (YOLO)
```{r}
## TO CONSIDER: 
# 1. make mean + SDs THE DARKEST version of the colour and check if they are visible and better than black!


source('/Volumes/Slim_Reaper/Projects/Language_MVPA/code/src/cosmo-mpva/mvpa_plot_functions.R')

blind_triple_colors <- c(brewer.pal(3, "Pastel2")[1], 
                         brewer.pal(3, "Dark2")[1],
                         brewer.pal(3, "Set2")[1])
#     
sighted_triple_colors <- c(brewer.pal(3, "Pastel2")[2], 
                           brewer.pal(3, "Dark2")[2],
                           brewer.pal(3, "Set2")[2])


for(r in seq_along(roi)){
    for(g in seq_along(groups)){
        
        #Slice the df to get given roi and group
        plot_df <- mvpa_joined_avg %>% 
            filter(roiArea == roi[r],
                   group == groups[g]) 
        
        #Slice the average summary df 
        avg_df <- mvpa_accuracy_avg %>% 
            filter(roiArea == roi[r],
                   group == groups[g]) 
        
        #make the basic plot with function
        plot_temp <- crossmodal_mvpa_plot_ReadSpeech(plot_df, avg_df) 
        
        #recolour the plot based on group
        if (groups[g] == 'blind') {
            
            plot_temp <- plot_temp + 
                scale_color_manual(values = blind_triple_colors,
                                   name = "Decoding partitions")
                
        } else if (groups[g] == 'sighted') {
            
            plot_temp <- plot_temp + 
                scale_color_manual(values = sighted_triple_colors,
                                   name = "Decoding partitions") 
        }

        # assign new name to the sub plot 
        assign(paste0('plot_temp_', groups[g]), plot_temp)
            rm(plot_temp)
        
    }
    #PASTE THIS ROI AFTER BOTH GORUPS ARE DONE WITH PATCHWORK!
    plot_joined_temp <- plot_temp_blind + plot_temp_sighted
    
    assign(paste('plot_crossmodal', roi[r], sep = '_'), plot_joined_temp)
    
    rm(plot_temp_blind, plot_temp_sighted, plot_joined_temp)
    
}

```
PLOT BOTH TRAIN-TEST PARTS
```{r}
# # PREDEFINE VARIABLES FOR THE PLOTS 
# # get plotting functions
# source('/Volumes/Slim_Reaper/Projects/Language_MVPA/code/src/cosmo-mpva/mvpa_plot_functions.R')
# 
# blind_triple_colors <- c(brewer.pal(3, "Pastel2")[1], 
#                          brewer.pal(3, "Dark2")[1],
#                          brewer.pal(3, "Set2")[1])
# #     
# sighted_triple_colors <- c(brewer.pal(3, "Pastel2")[2], 
#                            brewer.pal(3, "Dark2")[2],
#                            brewer.pal(3, "Set2")[2])
#  
#  
# dark_colors <- brewer.pal(n=3, name = "Dark2") 
# light_colors <- brewer.pal(n=3, name = "Pastel2") 
# 
# std.error <- function(x) sd(x)/sqrt(length(x))
# 
# #Use mvpa_accuracy_joined type of deal to name the conditions. BUT it's only in summaries, individual CSV files (mvpa_joined) do'nt have the accuracy averaged! 
# # Try to go back to fMRI ROI script and use condition by training set INTERACTION for mapping and use super light alpha + different borders for sub-training parts? 
# #         ggplot(aes(x = Modality, y = Contrast_Estimate, group = interaction(Modality, Condition), 
#                  #  color = Condition)) +
# 
# 
# ## TEST THE PLOT, SLOWLY, ONE GROUP ONE ROI 
# 
# plot_test <- mvpa_joined_avg %>% 
#     filter(roiArea == roi[1],
#            group == 'blind') %>% 
#     ggplot(aes(x = conditions, 
#                y = accuracy, 
#                color = TrainTest, 
#                alpha = TrainTest,
#                size = TrainTest,
#                group = interaction(conditions, TrainTest))) +
#     geom_point(position = position_jitterdodge(jitter.width=0.2,
#                                                dodge.width = 0.9)) +
#     
#     #scale_alpha_manual(values = c(0.2,0.8, 0.2), 
#     scale_alpha_manual(values = c(0.95,0.95, 0.95), 
#                        name = "Decoding partitions") +
#    # scale_color_manual(values = c(rep(dark_colors[1], 3)),
#     #scale_color_manual(values = blind_triple_colors,
#     #                   name = "Decoding partitions")+
#     scale_size_manual(values = c(1.75,4,1.75),
#                        name = "Decoding partitions")+
#     scale_y_continuous(name = "Clasisfier Accuracy [%]", 
#                        limits = c(0,100)) +
#     scale_x_discrete(name = 'Decoding conditions') +
#     ## ADD STAT SUMMARIES 
#     stat_summary(fun = "mean",
#                  geom = "crossbar",
#                  position = position_dodge(width = 0.9),
#                  width = .75,
#                  size = 0.75,
#                  #color = 'black',
#                  alpha = 1,
#                  show.legend = FALSE) +
#     stat_summary(fun.max = function(x) mean(x) + (sd(x)/sqrt(20)),
#                  fun.min = function(x) mean(x) - (sd(x)/sqrt(20)),
#                  geom = "errorbar",
#                  position = position_dodge(width = 0.9),
#                  width = .15,
#                  size = 0.8,
#                  alpha = 1,
#                  color = "black",
#                  show.legend = FALSE) +
#     #ADD CHANCE LINE
#     geom_hline(yintercept=c(50), 
#                linetype="dotted", 
#                colour="black", 
#                linewidth=.5) +
#     ## TRY TO ANNOTATE THE PLOTS WITH MEAN AND SEM VALUES - only average!? 
#    # annotate("text", 
#     #         x = classifier, 
#     #         y = 5, 
#     #         label = c(round(accu$mean_accuracy, digits = 2)))+
#     #annotate("text", 
#     #         x = classifier, 
#     #         y = 0, 
#     #         label = c(round(accu$se_accuracy, digits = 2))) +
#     theme_cowplot(font_size = 16, font_family = "Arial") +
#     theme(axis.line = element_line(colour = 'black', size = 1),
#           axis.ticks = element_line(colour = 'black', size = 1),
#           axis.text = element_text(face="bold"))
#     


```




Plotting loop across everything? Start easy
```{r}

dark_colors <- brewer.pal(n=3, name = "Dark2") 
light_colors <- brewer.pal(n=3, name = "Pastel2") 
std.error <- function(x) sd(x)/sqrt(length(x))

for(g in seq_along(groups)) {
    #for(m in seq_along(modalities)) {
      # for(c in seq_along(classifier)) {
            for (r in seq_along(roi)) {
        
            accu <- mvpa_accuracy %>% 
                filter(group == groups[g] & 
                           #conditions == classifier[c] & 
                          # modality == modalities[m] & 
                           ffxResults == ffx &
                           roiArea == roi[r])
                
                
           plot <- 
                mvpa_joined %>% 
                # Pick a condition and modality for this plot
                filter(group == groups[g] & 
                           #conditions == classifier[c] & 
                           #modality == modalities[m] & 
                           ffxResults == ffx &
                           roiArea == roi[r]) %>% 
                ggplot(aes(x = conditions, y = accuracy, color = roiArea)) +
                geom_point(aes(alpha = I(0.7)), 
                   position = position_jitterdodge(jitter.width=0.2,
                                                   dodge.width = 0.3),
                   size = 4.5) +
                stat_summary(aes(x =conditions, y = accuracy, color = roiArea),
                     fun = "mean", 
                     geom = "crossbar", 
                     position = position_dodge(width = 0.5),
                     width = .55,
                     colour  = 'black',
                     inherit.aes = FALSE,
                    show.legend = FALSE) + 
                stat_summary(aes(x = conditions, y = accuracy, color = roiArea),
                         fun.max = function(x) mean(x) + (std.error(x)), # sems too small for sighted
                         fun.min = function(x) mean(x) - (std.error(x)), # sems too small for sighted
                         #fun.max = function(x) mean(x) + sd(x),
                         #fun.min = function(x) mean(x) - sd(x),
                         geom = "errorbar",
                         position = position_dodge(width = 0.5),
                         width = .15,
                         size = 0.8,
                         colour  = 'black',
                         inherit.aes = FALSE,
                         show.legend = FALSE) + 
                geom_hline(yintercept=c(50), 
                       linetype="dotted", 
                       colour="black", 
                       linewidth=.5) +
                scale_color_manual(values = if(groups[g] == 'blind'){
                    c(rep(dark_colors[1], 3))
                } else if(groups[g] == 'sighted') {
                    c(rep(dark_colors[2], 3))
                }) +
                scale_y_continuous(name = "Clasisfier Accuracy [%]", 
                                   limits = c(0,100)) +
                scale_x_discrete(name = 'Decoding conditions') +
               # ggtitle(paste(groups[g], modalities[m], classifier[c], sep = ' ')) +
               # TRY TO ANNOTATE THE PLOTS WITH MEAN AND SEM VALUES? 
                annotate("text", 
                         x = classifier, 
                         y = 5, 
                         label = c(round(accu$mean_accuracy, digits = 2)))+
                annotate("text", 
                         x = classifier, 
                         y = 0, 
                         label = c(round(accu$se_accuracy, digits = 2))) +
                theme_cowplot(font_size = 16, font_family = "Arial") +
                theme(axis.line = element_line(colour = 'black', size = 1),
                      axis.ticks = element_line(colour = 'black', size = 1),
                      axis.text = element_text(face="bold"),
                      legend.position = 'none')
                
                           
            #Rename the plot based on what it represents 
            assign(paste('plot_crossmodal',groups[g], roi[r],  
                         sep = '_'), plot)
            rm(plot)
            
            }
      # }
   }
#}

```

